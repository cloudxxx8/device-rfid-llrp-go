//
// Copyright (C) 2020 Intel Corporation
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by "generate_param_code.py -i messages.yaml -s generated_structs.go -t binary_test.go -m generated_marshal.go -u generated_unmarshal.go -e generated_encoder.go"; DO NOT EDIT.

package llrp

import (
	"encoding/binary"
	"fmt"
)

// hasEnoughBytes returns an error if there aren't enough bytes to read the parameter.
func hasEnoughBytes(pt ParamType, needed, got int, exact bool) error {
	if needed <= got {
		return nil
	}
	if exact && needed == 0 {
		return fmt.Errorf("%v must be empty, but received %d byte(s)", pt,
			got)
	} else if exact {
		return fmt.Errorf("%v requires exactly %d byte(s), but received %d",
			pt, needed, got)
	}
	return fmt.Errorf("%v requires at least %d byte(s), but received %d",
		pt, needed, got)
}

// UnmarshalBinary Message 46, GetSupportedVersion.
func (m *GetSupportedVersion) UnmarshalBinary(data []byte) error {
	// GetSupportedVersion is a header-only message
	if len(data) > 0 {
		return fmt.Errorf("GetSupportedVersion should be empty, but has %d "+
			"bytes", len(data))
	}
	return nil
}

// UnmarshalBinary Message 56, GetSupportedVersionResponse.
func (m *GetSupportedVersionResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 10 {
		return fmt.Errorf("GetSupportedVersionResponse length should be at "+
			"least 10, but is %d", len(data))
	}
	m.CurrentVersion = VersionNum(data[0] >> 5)
	m.MaxSupportedVersion = VersionNum(data[1] >> 5)
	data = data[2:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading GetSupportedVersionResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 47, SetProtocolVersion.
func (m *SetProtocolVersion) UnmarshalBinary(data []byte) error {
	if len(data) != 1 {
		return fmt.Errorf("SetProtocolVersion should length should be "+
			"exactly 1, but is %d", len(data))
	}
	m.TargetVersion = VersionNum(data[0] >> 5)
	return nil
}

// UnmarshalBinary Message 57, SetProtocolVersionResponse.
func (m *SetProtocolVersionResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("SetProtocolVersionResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading SetProtocolVersionResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 1, GetReaderCapabilities.
func (m *GetReaderCapabilities) UnmarshalBinary(data []byte) error {
	if len(data) < 1 {
		return fmt.Errorf("GetReaderCapabilities length should be at least "+
			"1, but is %d", len(data))
	}
	m.ReaderCapabilitiesRequestedData = ReaderCapability(data[0])
	data = data[1:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading GetReaderCapabilities, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 11, GetReaderCapabilitiesResponse.
func (m *GetReaderCapabilitiesResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("GetReaderCapabilitiesResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamGeneralDeviceCapabilities:
			m.GeneralDeviceCapabilities = new(GeneralDeviceCapabilities)
			if err := m.GeneralDeviceCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamLLRPCapabilities:
			m.LLRPCapabilities = new(LLRPCapabilities)
			if err := m.LLRPCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamRegulatoryCapabilities:
			m.RegulatoryCapabilities = new(RegulatoryCapabilities)
			if err := m.RegulatoryCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2LLRPCapabilities:
			m.C1G2LLRPCapabilities = new(C1G2LLRPCapabilities)
			if err := m.C1G2LLRPCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading GetReaderCapabilitiesResponse, "+
			"but an unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 20, AddROSpec.
func (m *AddROSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 19 {
		return fmt.Errorf("AddROSpec length should be at least 19, but is "+
			"%d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROSpec {
		return fmt.Errorf("expected ParamROSpec, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamROSpec says it has %d bytes, but only %d "+
				"bytes remain", subLen, len(data))
		}
		if err := m.ROSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading AddROSpec, but an unexpected %d "+
			"bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 30, AddROSpecResponse.
func (m *AddROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("AddROSpecResponse length should be at least 8, "+
			"but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading AddROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 21, DeleteROSpec.
func (m *DeleteROSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return fmt.Errorf("DeleteROSpec should length should be exactly 4, "+
			"but is %d", len(data))
	}
	m.ROSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// UnmarshalBinary Message 31, DeleteROSpecResponse.
func (m *DeleteROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("DeleteROSpecResponse length should be at least 8, "+
			"but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading DeleteROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 22, StartROSpec.
func (m *StartROSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return fmt.Errorf("StartROSpec should length should be exactly 4, "+
			"but is %d", len(data))
	}
	m.ROSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// UnmarshalBinary Message 32, StartROSpecResponse.
func (m *StartROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("StartROSpecResponse length should be at least 8, "+
			"but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading StartROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 23, StopROSpec.
func (m *StopROSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return fmt.Errorf("StopROSpec should length should be exactly 4, but "+
			"is %d", len(data))
	}
	m.ROSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// UnmarshalBinary Message 33, StopROSpecResponse.
func (m *StopROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("StopROSpecResponse length should be at least 8, "+
			"but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading StopROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 24, EnableROSpec.
func (m *EnableROSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return fmt.Errorf("EnableROSpec should length should be exactly 4, "+
			"but is %d", len(data))
	}
	m.ROSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// UnmarshalBinary Message 34, EnableROSpecResponse.
func (m *EnableROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("EnableROSpecResponse length should be at least 8, "+
			"but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading EnableROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 25, DisableROSpec.
func (m *DisableROSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return fmt.Errorf("DisableROSpec should length should be exactly 4, "+
			"but is %d", len(data))
	}
	m.ROSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// UnmarshalBinary Message 35, DisableROSpecResponse.
func (m *DisableROSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("DisableROSpecResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading DisableROSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 26, GetROSpecs.
func (m *GetROSpecs) UnmarshalBinary(data []byte) error {
	// GetROSpecs is a header-only message
	if len(data) > 0 {
		return fmt.Errorf("GetROSpecs should be empty, but has %d bytes",
			len(data))
	}
	return nil
}

// UnmarshalBinary Message 36, GetROSpecsResponse.
func (m *GetROSpecsResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("GetROSpecsResponse length should be at least 8, "+
			"but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamROSpec:
			var tmp ROSpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.ROSpecs = append(m.ROSpecs, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading GetROSpecsResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 40, AddAccessSpec.
func (m *AddAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) < 23 {
		return fmt.Errorf("AddAccessSpec length should be at least 23, but "+
			"is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAccessSpec {
		return fmt.Errorf("expected ParamAccessSpec, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamAccessSpec says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.AccessSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading AddAccessSpec, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 50, AddAccessSpecResponse.
func (m *AddAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("AddAccessSpecResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading AddAccessSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 41, DeleteAccessSpec.
func (m *DeleteAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return fmt.Errorf("DeleteAccessSpec should length should be exactly "+
			"4, but is %d", len(data))
	}
	m.AccessSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// UnmarshalBinary Message 51, DeleteAccessSpecResponse.
func (m *DeleteAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("DeleteAccessSpecResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading DeleteAccessSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 42, EnableAccessSpec.
func (m *EnableAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return fmt.Errorf("EnableAccessSpec should length should be exactly "+
			"4, but is %d", len(data))
	}
	m.AccessSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// UnmarshalBinary Message 52, EnableAccessSpecResponse.
func (m *EnableAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("EnableAccessSpecResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading EnableAccessSpecResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 43, DisableAccessSpec.
func (m *DisableAccessSpec) UnmarshalBinary(data []byte) error {
	if len(data) != 4 {
		return fmt.Errorf("DisableAccessSpec should length should be exactly "+
			"4, but is %d", len(data))
	}
	m.AccessSpecID = binary.BigEndian.Uint32(data)
	return nil
}

// UnmarshalBinary Message 53, DisableAccessSpecResponse.
func (m *DisableAccessSpecResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("DisableAccessSpecResponse length should be at "+
			"least 8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading DisableAccessSpecResponse, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 44, GetAccessSpecs.
func (m *GetAccessSpecs) UnmarshalBinary(data []byte) error {
	// GetAccessSpecs is a header-only message
	if len(data) > 0 {
		return fmt.Errorf("GetAccessSpecs should be empty, but has %d "+
			"bytes", len(data))
	}
	return nil
}

// UnmarshalBinary Message 54, GetAccessSpecsResponse.
func (m *GetAccessSpecsResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("GetAccessSpecsResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamAccessSpec:
			var tmp AccessSpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.AccessSpecs = append(m.AccessSpecs, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading GetAccessSpecsResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 45, ClientRequestOp.
func (m *ClientRequestOp) UnmarshalBinary(data []byte) error {
	if len(data) < 10 {
		return fmt.Errorf("ClientRequestOp length should be at least 10, but "+
			"is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamTagReportData {
		return fmt.Errorf("expected ParamTagReportData, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamTagReportData says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := m.TagReportData.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading ClientRequestOp, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 55, ClientRequestOpResponse.
func (m *ClientRequestOpResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 14 {
		return fmt.Errorf("ClientRequestOpResponse length should be at least "+
			"14, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamClientRequestResponse {
		return fmt.Errorf("expected ParamClientRequestResponse, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamClientRequestResponse says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		if err := m.ClientRequestResponse.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading ClientRequestOpResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 60, GetReport.
func (m *GetReport) UnmarshalBinary(data []byte) error {
	// GetReport is a header-only message
	if len(data) > 0 {
		return fmt.Errorf("GetReport should be empty, but has %d bytes",
			len(data))
	}
	return nil
}

// UnmarshalBinary Message 61, ROAccessReport.
func (m *ROAccessReport) UnmarshalBinary(data []byte) error {
	if len(data) < 0 {
		return fmt.Errorf("ROAccessReport length should be at least 0, but "+
			"is %d", len(data))
	}
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamTagReportData:
			var tmp TagReportData
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.TagReportData = append(m.TagReportData, tmp)
		case ParamRFSurveyReportData:
			var tmp RFSurveyReportData
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.RFSurveyReportData = append(m.RFSurveyReportData, tmp)
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading ROAccessReport, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 62, KeepAlive.
func (m *KeepAlive) UnmarshalBinary(data []byte) error {
	// KeepAlive is a header-only message
	if len(data) > 0 {
		return fmt.Errorf("KeepAlive should be empty, but has %d bytes",
			len(data))
	}
	return nil
}

// UnmarshalBinary Message 72, KeepAliveAck.
func (m *KeepAliveAck) UnmarshalBinary(data []byte) error {
	// KeepAliveAck is a header-only message
	if len(data) > 0 {
		return fmt.Errorf("KeepAliveAck should be empty, but has %d bytes",
			len(data))
	}
	return nil
}

// UnmarshalBinary Message 63, ReaderEventNotification.
func (m *ReaderEventNotification) UnmarshalBinary(data []byte) error {
	if len(data) < 16 {
		return fmt.Errorf("ReaderEventNotification length should be at least "+
			"16, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamReaderEventNotificationData {
		return fmt.Errorf("expected ParamReaderEventNotificationData, but "+
			"found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamReaderEventNotificationData says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := m.ReaderEventNotificationData.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading ReaderEventNotification, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 64, EnableEventsAndReports.
func (m *EnableEventsAndReports) UnmarshalBinary(data []byte) error {
	// EnableEventsAndReports is a header-only message
	if len(data) > 0 {
		return fmt.Errorf("EnableEventsAndReports should be empty, but has "+
			"%d bytes", len(data))
	}
	return nil
}

// UnmarshalBinary Message 100, ErrorMessage.
func (m *ErrorMessage) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("ErrorMessage length should be at least 8, but is "+
			"%d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading ErrorMessage, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 2, GetReaderConfig.
func (m *GetReaderConfig) UnmarshalBinary(data []byte) error {
	if len(data) < 7 {
		return fmt.Errorf("GetReaderConfig length should be at least 7, but "+
			"is %d", len(data))
	}
	m.AntennaID = AntennaID(binary.BigEndian.Uint16(data))
	m.RequestedData = ReaderConfigRequestedDataType(data[2])
	m.GPIPortNum = binary.BigEndian.Uint16(data[3:])
	m.GPOPortNum = binary.BigEndian.Uint16(data[5:])
	data = data[7:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading GetReaderConfig, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 12, GetReaderConfigResponse.
func (m *GetReaderConfigResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("GetReaderConfigResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamIdentification {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamIdentification says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		m.Identification = new(Identification)
		if err := m.Identification.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamAntennaProperties:
			var tmp AntennaProperties
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.AntennaProperties = append(m.AntennaProperties, tmp)
		case ParamAntennaConfiguration:
			var tmp AntennaConfiguration
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.AntennaConfigurations = append(m.AntennaConfigurations, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup3:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamReaderEventNotificationSpec:
			m.ReaderEventNotificationSpec = new(ReaderEventNotificationSpec)
			if err := m.ReaderEventNotificationSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamROReportSpec:
			m.ROReportSpec = new(ROReportSpec)
			if err := m.ROReportSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamAccessReportSpec:
			m.AccessReportSpec = new(AccessReportSpec)
			*m.AccessReportSpec = AccessReportSpec(AccessReportTriggerType(data[4]))
		case ParamLLRPConfigurationStateValue:
			m.LLRPConfigurationStateValue = new(LLRPConfigurationStateValue)
			*m.LLRPConfigurationStateValue = LLRPConfigurationStateValue(binary.BigEndian.Uint32(data[4:]))
		case ParamKeepAliveSpec:
			m.KeepAliveSpec = new(KeepAliveSpec)
			if err := m.KeepAliveSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup3
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup4:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamGPIPortCurrentState:
			var tmp GPIPortCurrentState
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.GPIPortCurrentStates = append(m.GPIPortCurrentStates, tmp)
		case ParamGPOWriteData:
			var tmp GPOWriteData
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.GPOWriteData = append(m.GPOWriteData, tmp)
		default:
			break paramGroup4
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamEventsAndReports {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamEventsAndReports says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		m.EventsAndReports = new(EventsAndReports)
		*m.EventsAndReports = EventsAndReports(data[4]>>7 != 0)
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup6:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup6
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading GetReaderConfigResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 3, SetReaderConfig.
func (m *SetReaderConfig) UnmarshalBinary(data []byte) error {
	if len(data) < 1 {
		return fmt.Errorf("SetReaderConfig length should be at least 1, but "+
			"is %d", len(data))
	}
	m.ResetToFactoryDefaults = data[0]>>7 != 0
	data = data[1:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamReaderEventNotificationSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamReaderEventNotificationSpec says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		m.ReaderEventNotificationSpec = new(ReaderEventNotificationSpec)
		if err := m.ReaderEventNotificationSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamAntennaProperties:
			var tmp AntennaProperties
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.AntennaProperties = append(m.AntennaProperties, tmp)
		case ParamAntennaConfiguration:
			var tmp AntennaConfiguration
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.AntennaConfigurations = append(m.AntennaConfigurations, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamROReportSpec:
			m.ROReportSpec = new(ROReportSpec)
			if err := m.ROReportSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamAccessReportSpec:
			m.AccessReportSpec = new(AccessReportSpec)
			*m.AccessReportSpec = AccessReportSpec(AccessReportTriggerType(data[4]))
		case ParamKeepAliveSpec:
			m.KeepAliveSpec = new(KeepAliveSpec)
			if err := m.KeepAliveSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup3:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamGPOWriteData:
			var tmp GPOWriteData
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.GPOWriteData = append(m.GPOWriteData, tmp)
		case ParamGPIPortCurrentState:
			var tmp GPIPortCurrentState
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.GPIPortCurrentStates = append(m.GPIPortCurrentStates, tmp)
		default:
			break paramGroup3
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamEventsAndReports {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamEventsAndReports says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		m.EventsAndReports = new(EventsAndReports)
		*m.EventsAndReports = EventsAndReports(data[4]>>7 != 0)
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup5:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			m.Custom = append(m.Custom, tmp)
		default:
			break paramGroup5
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading SetReaderConfig, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 13, SetReaderConfigResponse.
func (m *SetReaderConfigResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("SetReaderConfigResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading SetReaderConfigResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 14, CloseConnection.
func (m *CloseConnection) UnmarshalBinary(data []byte) error {
	// CloseConnection is a header-only message
	if len(data) > 0 {
		return fmt.Errorf("CloseConnection should be empty, but has %d "+
			"bytes", len(data))
	}
	return nil
}

// UnmarshalBinary Message 4, CloseConnectionResponse.
func (m *CloseConnectionResponse) UnmarshalBinary(data []byte) error {
	if len(data) < 8 {
		return fmt.Errorf("CloseConnectionResponse length should be at least "+
			"8, but is %d", len(data))
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamLLRPStatus {
		return fmt.Errorf("expected ParamLLRPStatus, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamLLRPStatus says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := m.LLRPStatus.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading CloseConnectionResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Message 1023, CustomMessage.
func (m *CustomMessage) UnmarshalBinary(data []byte) error {
	if len(data) < 5 {
		return fmt.Errorf("CustomMessage length should be at least 5, but is "+
			"%d", len(data))
	}
	m.VendorID = binary.BigEndian.Uint32(data)
	m.MessageSubtype = data[4]
	if len(data)-5 == 0 {
		return nil
	}
	m.Data = make([]byte, len(data)-5)
	copy(m.Data, data[5:])
	data = data[5:]
	return nil
}

// UnmarshalBinary Parameter 1, AntennaID.
func (p *AntennaID) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAntennaID, 2, len(data), true); err != nil {
		return err
	}
	*p = AntennaID(binary.BigEndian.Uint16(data))
	return nil
}

// UnmarshalBinary Parameter 2, FirstSeenUTC.
func (p *FirstSeenUTC) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFirstSeenUTC, 8, len(data), true); err != nil {
		return err
	}
	*p = FirstSeenUTC(binary.BigEndian.Uint64(data))
	return nil
}

// UnmarshalBinary Parameter 3, FirstSeenUptime.
func (p *FirstSeenUptime) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFirstSeenUptime, 8, len(data), true); err != nil {
		return err
	}
	*p = FirstSeenUptime(binary.BigEndian.Uint64(data))
	return nil
}

// UnmarshalBinary Parameter 4, LastSeenUTC.
func (p *LastSeenUTC) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLastSeenUTC, 8, len(data), true); err != nil {
		return err
	}
	*p = LastSeenUTC(binary.BigEndian.Uint64(data))
	return nil
}

// UnmarshalBinary Parameter 5, LastSeenUptime.
func (p *LastSeenUptime) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLastSeenUptime, 8, len(data), true); err != nil {
		return err
	}
	*p = LastSeenUptime(binary.BigEndian.Uint64(data))
	return nil
}

// UnmarshalBinary Parameter 6, PeakRSSI.
func (p *PeakRSSI) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamPeakRSSI, 1, len(data), true); err != nil {
		return err
	}
	*p = PeakRSSI(DecibelMilliwatt8(data[0]))
	return nil
}

// UnmarshalBinary Parameter 7, ChannelIndex.
func (p *ChannelIndex) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamChannelIndex, 2, len(data), true); err != nil {
		return err
	}
	*p = ChannelIndex(binary.BigEndian.Uint16(data))
	return nil
}

// UnmarshalBinary Parameter 8, TagSeenCount.
func (p *TagSeenCount) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamTagSeenCount, 2, len(data), true); err != nil {
		return err
	}
	*p = TagSeenCount(binary.BigEndian.Uint16(data))
	return nil
}

// UnmarshalBinary Parameter 9, ROSpecID.
func (p *ROSpecID) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROSpecID, 4, len(data), true); err != nil {
		return err
	}
	*p = ROSpecID(binary.BigEndian.Uint32(data))
	return nil
}

// UnmarshalBinary Parameter 10, InventoryParameterSpecID.
func (p *InventoryParameterSpecID) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamInventoryParameterSpecID, 2, len(data), true); err != nil {
		return err
	}
	*p = InventoryParameterSpecID(binary.BigEndian.Uint16(data))
	return nil
}

// UnmarshalBinary Parameter 11, C1G2CRC.
func (p *C1G2CRC) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2CRC, 2, len(data), true); err != nil {
		return err
	}
	*p = C1G2CRC(binary.BigEndian.Uint16(data))
	return nil
}

// UnmarshalBinary Parameter 12, C1G2PC.
func (p *C1G2PC) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2PC, 2, len(data), true); err != nil {
		return err
	}
	p.EPCMemoryLength = data[0] >> 3
	p.HasUserMemory = data[0]>>2&1 != 0
	p.HasXPC = data[0]>>1&1 != 0
	p.IsISO15961 = data[0]&1 != 0
	p.AttributesOrAFI = byte(data[1])
	return nil
}

// UnmarshalBinary Parameter 13, EPC96.
func (p *EPC96) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamEPC96, 12, len(data), true); err != nil {
		return err
	}
	p.EPC = make([]byte, 12)
	copy(p.EPC, data)
	return nil
}

// UnmarshalBinary Parameter 14, SpecIndex.
func (p *SpecIndex) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamSpecIndex, 2, len(data), true); err != nil {
		return err
	}
	*p = SpecIndex(binary.BigEndian.Uint16(data))
	return nil
}

// UnmarshalBinary Parameter 15, ClientRequestOpSpecResult.
func (p *ClientRequestOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamClientRequestOpSpecResult, 2, len(data), true); err != nil {
		return err
	}
	*p = ClientRequestOpSpecResult(binary.BigEndian.Uint16(data))
	return nil
}

// UnmarshalBinary Parameter 16, AccessSpecID.
func (p *AccessSpecID) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAccessSpecID, 4, len(data), true); err != nil {
		return err
	}
	*p = AccessSpecID(binary.BigEndian.Uint32(data))
	return nil
}

// UnmarshalBinary Parameter 17, OpSpecID.
func (p *OpSpecID) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamOpSpecID, 2, len(data), true); err != nil {
		return err
	}
	*p = OpSpecID(binary.BigEndian.Uint16(data))
	return nil
}

// UnmarshalBinary Parameter 18, C1G2SingulationDetails.
func (p *C1G2SingulationDetails) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2SingulationDetails, 4, len(data), true); err != nil {
		return err
	}
	p.NumCollisionSlots = binary.BigEndian.Uint16(data)
	p.NumEmptySlots = binary.BigEndian.Uint16(data[2:])
	return nil
}

// UnmarshalBinary Parameter 19, C1G2XPCW1.
func (p *C1G2XPCW1) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2XPCW1, 2, len(data), true); err != nil {
		return err
	}
	*p = C1G2XPCW1(binary.BigEndian.Uint16(data))
	return nil
}

// UnmarshalBinary Parameter 20, C1G2XPCW2.
func (p *C1G2XPCW2) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2XPCW2, 2, len(data), true); err != nil {
		return err
	}
	*p = C1G2XPCW2(binary.BigEndian.Uint16(data))
	return nil
}

// UnmarshalBinary Parameter 128, UTCTimestamp.
func (p *UTCTimestamp) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamUTCTimestamp, 8, len(data), true); err != nil {
		return err
	}
	*p = UTCTimestamp(binary.BigEndian.Uint64(data))
	return nil
}

// UnmarshalBinary Parameter 129, Uptime.
func (p *Uptime) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamUptime, 8, len(data), true); err != nil {
		return err
	}
	*p = Uptime(binary.BigEndian.Uint64(data))
	return nil
}

// UnmarshalBinary Parameter 137, GeneralDeviceCapabilities.
func (p *GeneralDeviceCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGeneralDeviceCapabilities, 30, len(data), false); err != nil {
		return err
	}
	p.MaxSupportedAntennas = binary.BigEndian.Uint16(data)
	p.CanSetAntennaProperties = data[2]>>7 != 0
	p.HasUTCClock = data[2]>>6&1 != 0
	p.DeviceManufacturer = binary.BigEndian.Uint32(data[4:])
	p.Model = binary.BigEndian.Uint32(data[8:])
	if strLen := int(binary.BigEndian.Uint16(data[12:])); strLen > len(data[14:]) {
		return fmt.Errorf("FirmwareVersion (string) declares it has %d "+
			"bytes, but only %d bytes are available", strLen, len(data[14:]))
	} else if strLen != 0 {
		p.FirmwareVersion = string(data[14 : strLen+14])
		data = data[strLen+14:]
	} else {
		data = data[14:]
	}
	// sub-parameters

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamReceiveSensitivityTableEntry:
			var tmp ReceiveSensitivityTableEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.ReceiveSensitivities = append(p.ReceiveSensitivities, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamPerAntennaReceiveSensitivityRange:
			var tmp PerAntennaReceiveSensitivityRange
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.PerAntennaReceiveSensitivityRanges = append(p.PerAntennaReceiveSensitivityRanges, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if err := hasEnoughBytes(ParamGPIOCapabilities, 8, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamGPIOCapabilities {
		return fmt.Errorf("expected ParamGPIOCapabilities, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamGPIOCapabilities says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := p.GPIOCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}

paramGroup3:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamPerAntennaAirProtocol:
			var tmp PerAntennaAirProtocol
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.PerAntennaAirProtocols = append(p.PerAntennaAirProtocols, tmp)
		default:
			break paramGroup3
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamMaximumReceiveSensitivity {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamMaximumReceiveSensitivity says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		p.MaximumReceiveSensitivity = new(MaximumReceiveSensitivity)
		*p.MaximumReceiveSensitivity = MaximumReceiveSensitivity(DecibelMilliwatt16(binary.BigEndian.Uint16(data[4:])))
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading GeneralDeviceCapabilities, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 139, ReceiveSensitivityTableEntry.
func (p *ReceiveSensitivityTableEntry) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReceiveSensitivityTableEntry, 4, len(data), true); err != nil {
		return err
	}
	p.Index = binary.BigEndian.Uint16(data)
	p.ReceiveSensitivity = binary.BigEndian.Uint16(data[2:])
	return nil
}

// UnmarshalBinary Parameter 140, PerAntennaAirProtocol.
func (p *PerAntennaAirProtocol) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamPerAntennaAirProtocol, 4, len(data), false); err != nil {
		return err
	}
	p.AntennaID = AntennaID(binary.BigEndian.Uint16(data))
	if arrLen := int(binary.BigEndian.Uint16(data[2:])); arrLen > len(data[4:]) {
		return fmt.Errorf("AirProtocolIDs ([]AirProtocolIDType) declares it "+
			"has %d bytes, but only %d bytes are available", arrLen,
			len(data[4:]))
	} else if arrLen != 0 {
		p.AirProtocolIDs = make([]AirProtocolIDType, arrLen)
		for i := 0; i < arrLen; i++ {
			p.AirProtocolIDs[i] = AirProtocolIDType(data[i+4])
		}
		data = data[arrLen+4:]
	} else {
		data = data[4:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading PerAntennaAirProtocol, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 141, GPIOCapabilities.
func (p *GPIOCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGPIOCapabilities, 4, len(data), true); err != nil {
		return err
	}
	p.NumGPIs = binary.BigEndian.Uint16(data)
	p.NumGPOs = binary.BigEndian.Uint16(data[2:])
	return nil
}

// UnmarshalBinary Parameter 142, LLRPCapabilities.
func (p *LLRPCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLLRPCapabilities, 24, len(data), true); err != nil {
		return err
	}
	p.CanDoRFSurvey = data[0]>>7 != 0
	p.CanReportBufferFillWarning = data[0]>>6&1 != 0
	p.SupportsClientRequestOpSpec = data[0]>>5&1 != 0
	p.CanDoTagInventoryStateAwareSingulation = data[0]>>4&1 != 0
	p.SupportsEventsAndReportHolding = data[0]>>3&1 != 0
	p.MaxPriorityLevelSupported = data[1]
	p.ClientRequestedOpSpecTimeout = binary.BigEndian.Uint16(data[2:])
	p.MaxROSpecs = binary.BigEndian.Uint32(data[4:])
	p.MaxSpecsPerROSpec = binary.BigEndian.Uint32(data[8:])
	p.MaxInventoryParameterSpecsPerAISpec = binary.BigEndian.Uint32(data[12:])
	p.MaxAccessSpecs = binary.BigEndian.Uint32(data[16:])
	p.MaxOpSpecsPerAccessSpec = binary.BigEndian.Uint32(data[20:])
	return nil
}

// UnmarshalBinary Parameter 143, RegulatoryCapabilities.
func (p *RegulatoryCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRegulatoryCapabilities, 4, len(data), false); err != nil {
		return err
	}
	p.CountryCode = CountryCodeType(binary.BigEndian.Uint16(data))
	p.CommunicationsStandard = binary.BigEndian.Uint16(data[2:])
	data = data[4:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamUHFBandCapabilities {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamUHFBandCapabilities says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		p.UHFBandCapabilities = new(UHFBandCapabilities)
		if err := p.UHFBandCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading RegulatoryCapabilities, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 144, UHFBandCapabilities.
func (p *UHFBandCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamUHFBandCapabilities, 5, len(data), false); err != nil {
		return err
	}
	// sub-parameters

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamTransmitPowerLevelTableEntry:
			var tmp TransmitPowerLevelTableEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.TransmitPowerLevels = append(p.TransmitPowerLevels, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if err := hasEnoughBytes(ParamFrequencyInformation, 4, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamFrequencyInformation {
		return fmt.Errorf("expected ParamFrequencyInformation, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamFrequencyInformation says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		if err := p.FrequencyInformation.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if err := hasEnoughBytes(ParamUHFC1G2RFModeTable, 4, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamUHFC1G2RFModeTable {
		return fmt.Errorf("expected ParamUHFC1G2RFModeTable, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamUHFC1G2RFModeTable says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		if err := p.C1G2RFModes.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamRFSurveyFrequencyCapabilities {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamRFSurveyFrequencyCapabilities says it has "+
				"%d bytes, but only %d bytes remain", subLen, len(data))
		}
		p.RFSurveyFrequencyCapabilities = new(RFSurveyFrequencyCapabilities)
		if err := p.RFSurveyFrequencyCapabilities.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading UHFBandCapabilities, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 145, TransmitPowerLevelTableEntry.
func (p *TransmitPowerLevelTableEntry) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamTransmitPowerLevelTableEntry, 4, len(data), true); err != nil {
		return err
	}
	p.Index = binary.BigEndian.Uint16(data)
	p.TransmitPowerValue = MillibelMilliwatt(binary.BigEndian.Uint16(data[2:]))
	return nil
}

// UnmarshalBinary Parameter 146, FrequencyInformation.
func (p *FrequencyInformation) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFrequencyInformation, 1, len(data), false); err != nil {
		return err
	}
	p.Hopping = data[0]>>7 != 0
	data = data[1:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamFrequencyHopTable:
			var tmp FrequencyHopTable
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.FrequencyHopTables = append(p.FrequencyHopTables, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamFixedFrequencyTable {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamFixedFrequencyTable says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		p.FixedFrequencyTable = new(FixedFrequencyTable)
		if err := p.FixedFrequencyTable.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading FrequencyInformation, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 147, FrequencyHopTable.
func (p *FrequencyHopTable) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFrequencyHopTable, 4, len(data), false); err != nil {
		return err
	}
	p.HopTableID = data[0]
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[2:])); int64(arrLen)*4 > int64(len(data[4:])) {
		return fmt.Errorf("Frequencies ([]Kilohertz) declares it has %d*4 "+
			"bytes, but only %d bytes are available", arrLen, len(data[4:]))
	} else if arrLen != 0 {
		p.Frequencies = make([]Kilohertz, arrLen)
		for i, pos := 0, 4; i < arrLen; i, pos = i+1, pos+4 {
			p.Frequencies[i] = binary.BigEndian.Uint32(data[pos:])
		}
		data = data[arrLen*4+4:]
	} else {
		data = data[4:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading FrequencyHopTable, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 148, FixedFrequencyTable.
func (p *FixedFrequencyTable) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFixedFrequencyTable, 2, len(data), false); err != nil {
		return err
	}
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data)); int64(arrLen)*4 > int64(len(data[2:])) {
		return fmt.Errorf("Frequencies ([]Kilohertz) declares it has %d*4 "+
			"bytes, but only %d bytes are available", arrLen, len(data[2:]))
	} else if arrLen != 0 {
		p.Frequencies = make([]Kilohertz, arrLen)
		for i, pos := 0, 2; i < arrLen; i, pos = i+1, pos+4 {
			p.Frequencies[i] = binary.BigEndian.Uint32(data[pos:])
		}
		data = data[arrLen*4+2:]
	} else {
		data = data[2:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading FixedFrequencyTable, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 149, PerAntennaReceiveSensitivityRange.
func (p *PerAntennaReceiveSensitivityRange) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamPerAntennaReceiveSensitivityRange, 6, len(data), true); err != nil {
		return err
	}
	p.AntennaID = AntennaID(binary.BigEndian.Uint16(data))
	p.ReceiveSensitivityIndexMin = binary.BigEndian.Uint16(data[2:])
	p.ReceiveSensitivityIndexMax = binary.BigEndian.Uint16(data[4:])
	return nil
}

// UnmarshalBinary Parameter 177, ROSpec.
func (p *ROSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROSpec, 15, len(data), false); err != nil {
		return err
	}
	p.ROSpecID = binary.BigEndian.Uint32(data)
	p.Priority = data[4]
	p.ROSpecCurrentState = ROSpecCurrentStateType(data[5])
	data = data[6:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROBoundarySpec {
		return fmt.Errorf("expected ParamROBoundarySpec, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamROBoundarySpec says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := p.ROBoundarySpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamAISpec:
			var tmp AISpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.AISpecs = append(p.AISpecs, tmp)
		case ParamRFSurveySpec:
			var tmp RFSurveySpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.RFSurveySpecs = append(p.RFSurveySpecs, tmp)
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamLoopSpec:
			p.LoopSpec = new(LoopSpec)
			*p.LoopSpec = LoopSpec(binary.BigEndian.Uint32(data[4:]))
		case ParamROReportSpec:
			p.ROReportSpec = new(ROReportSpec)
			if err := p.ROReportSpec.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading ROSpec, but an unexpected %d "+
			"bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 178, ROBoundarySpec.
func (p *ROBoundarySpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROBoundarySpec, 5, len(data), false); err != nil {
		return err
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROSpecStartTrigger {
		return fmt.Errorf("expected ParamROSpecStartTrigger, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamROSpecStartTrigger says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		if err := p.StartTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if err := hasEnoughBytes(ParamROSpecStopTrigger, 4, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamROSpecStopTrigger {
		return fmt.Errorf("expected ParamROSpecStopTrigger, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamROSpecStopTrigger says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := p.StopTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading ROBoundarySpec, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 179, ROSpecStartTrigger.
func (p *ROSpecStartTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROSpecStartTrigger, 1, len(data), false); err != nil {
		return err
	}
	p.Trigger = ROSpecStartTriggerType(data[0])
	data = data[1:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamPeriodicTriggerValue:
			p.PeriodicTrigger = new(PeriodicTriggerValue)
			if err := p.PeriodicTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamGPITriggerValue:
			p.GPITrigger = new(GPITriggerValue)
			if err := p.GPITrigger.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading ROSpecStartTrigger, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 180, PeriodicTriggerValue.
func (p *PeriodicTriggerValue) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamPeriodicTriggerValue, 8, len(data), false); err != nil {
		return err
	}
	p.Offset = binary.BigEndian.Uint32(data)
	p.Period = binary.BigEndian.Uint32(data[4:])
	data = data[8:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamUTCTimestamp {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamUTCTimestamp says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		p.UTCTimestamp = new(UTCTimestamp)
		*p.UTCTimestamp = UTCTimestamp(binary.BigEndian.Uint64(data[4:]))
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading PeriodicTriggerValue, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 181, GPITriggerValue.
func (p *GPITriggerValue) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGPITriggerValue, 7, len(data), true); err != nil {
		return err
	}
	p.Port = binary.BigEndian.Uint16(data)
	p.Event = data[2]>>7 != 0
	p.Timeout = binary.BigEndian.Uint32(data[3:])
	return nil
}

// UnmarshalBinary Parameter 182, ROSpecStopTrigger.
func (p *ROSpecStopTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROSpecStopTrigger, 5, len(data), false); err != nil {
		return err
	}
	p.Trigger = ROSpecStopTriggerType(data[0])
	p.DurationTriggerValue = binary.BigEndian.Uint32(data[1:])
	data = data[5:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamGPITriggerValue {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamGPITriggerValue says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		p.GPITriggerValue = new(GPITriggerValue)
		if err := p.GPITriggerValue.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading ROSpecStopTrigger, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 183, AISpec.
func (p *AISpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAISpec, 9, len(data), false); err != nil {
		return err
	}
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data)); int64(arrLen)*2 > int64(len(data[2:])) {
		return fmt.Errorf("AntennaIDs ([]AntennaID) declares it has %d*2 "+
			"bytes, but only %d bytes are available", arrLen, len(data[2:]))
	} else if arrLen != 0 {
		p.AntennaIDs = make([]AntennaID, arrLen)
		for i, pos := 0, 2; i < arrLen; i, pos = i+1, pos+2 {
			p.AntennaIDs[i] = AntennaID(binary.BigEndian.Uint16(data[pos:]))
		}
		data = data[arrLen*2+2:]
	} else {
		data = data[2:]
	}
	// sub-parameters
	if err := hasEnoughBytes(ParamAISpecStopTrigger, 4, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAISpecStopTrigger {
		return fmt.Errorf("expected ParamAISpecStopTrigger, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamAISpecStopTrigger says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := p.StopTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamInventoryParameterSpec:
			var tmp InventoryParameterSpec
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.InventoryParameterSpecs = append(p.InventoryParameterSpecs, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading AISpec, but an unexpected %d "+
			"bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 184, AISpecStopTrigger.
func (p *AISpecStopTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAISpecStopTrigger, 5, len(data), false); err != nil {
		return err
	}
	p.Trigger = AISpecStopTriggerType(data[0])
	p.DurationTriggerValue = binary.BigEndian.Uint32(data[1:])
	data = data[5:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamGPITriggerValue:
			p.GPITrigger = new(GPITriggerValue)
			if err := p.GPITrigger.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamTagObservationTrigger:
			p.TagObservationTrigger = new(TagObservationTrigger)
			if err := p.TagObservationTrigger.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading AISpecStopTrigger, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 185, TagObservationTrigger.
func (p *TagObservationTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamTagObservationTrigger, 12, len(data), true); err != nil {
		return err
	}
	p.Trigger = TagObservationTriggerType(data[0])
	p.NumberOfTags = binary.BigEndian.Uint16(data[2:])
	p.NumberOfAttempts = binary.BigEndian.Uint16(data[4:])
	p.T = binary.BigEndian.Uint16(data[6:])
	p.Timeout = binary.BigEndian.Uint32(data[8:])
	return nil
}

// UnmarshalBinary Parameter 186, InventoryParameterSpec.
func (p *InventoryParameterSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamInventoryParameterSpec, 3, len(data), false); err != nil {
		return err
	}
	p.InventoryParameterSpecID = binary.BigEndian.Uint16(data)
	p.AirProtocolID = AirProtocolIDType(data[2])
	data = data[3:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamAntennaConfiguration:
			var tmp AntennaConfiguration
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.AntennaConfigurations = append(p.AntennaConfigurations, tmp)
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading InventoryParameterSpec, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 187, RFSurveySpec.
func (p *RFSurveySpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFSurveySpec, 23, len(data), false); err != nil {
		return err
	}
	p.AntennaID = AntennaID(binary.BigEndian.Uint16(data))
	p.StartFrequency = binary.BigEndian.Uint32(data[2:])
	p.EndFrequency = binary.BigEndian.Uint32(data[6:])
	data = data[10:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamRFSurveySpecStopTrigger {
		return fmt.Errorf("expected ParamRFSurveySpecStopTrigger, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamRFSurveySpecStopTrigger says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := p.Trigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading RFSurveySpec, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 188, RFSurveySpecStopTrigger.
func (p *RFSurveySpecStopTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFSurveySpecStopTrigger, 9, len(data), true); err != nil {
		return err
	}
	p.Trigger = RFSurveySpecStopTriggerType(data[0])
	p.Duration = binary.BigEndian.Uint32(data[1:])
	p.N = binary.BigEndian.Uint32(data[5:])
	return nil
}

// UnmarshalBinary Parameter 207, AccessSpec.
func (p *AccessSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAccessSpec, 19, len(data), false); err != nil {
		return err
	}
	p.AccessSpecID = binary.BigEndian.Uint32(data)
	p.AntennaID = AntennaID(binary.BigEndian.Uint16(data[4:]))
	p.AirProtocolID = AirProtocolIDType(data[6])
	p.IsActive = data[7]>>7 != 0
	p.ROSpecID = binary.BigEndian.Uint32(data[8:])
	data = data[12:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAccessSpecStopTrigger {
		return fmt.Errorf("expected ParamAccessSpecStopTrigger, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamAccessSpecStopTrigger says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		if err := p.Trigger.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if err := hasEnoughBytes(ParamAccessCommand, 4, len(data), false); err != nil {
		return err
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamAccessCommand {
		return fmt.Errorf("expected ParamAccessCommand, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamAccessCommand says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := p.AccessCommand.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamAccessReportSpec {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamAccessReportSpec says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		p.AccessReportSpec = new(AccessReportSpec)
		*p.AccessReportSpec = AccessReportSpec(AccessReportTriggerType(data[4]))
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading AccessSpec, but an unexpected %d "+
			"bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 208, AccessSpecStopTrigger.
func (p *AccessSpecStopTrigger) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAccessSpecStopTrigger, 3, len(data), true); err != nil {
		return err
	}
	p.Trigger = AccessSpecStopTriggerType(data[0])
	p.OperationCountValue = binary.BigEndian.Uint16(data[1:])
	return nil
}

// UnmarshalBinary Parameter 209, AccessCommand.
func (p *AccessCommand) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAccessCommand, 15, len(data), false); err != nil {
		return err
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamC1G2TagSpec {
		return fmt.Errorf("expected ParamC1G2TagSpec, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamC1G2TagSpec says it has %d bytes, but only "+
				"%d bytes remain", subLen, len(data))
		}
		if err := p.C1G2TagSpec.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2Read:
			p.C1G2Read = new(C1G2Read)
			if err := p.C1G2Read.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Write:
			p.C1G2Write = new(C1G2Write)
			if err := p.C1G2Write.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Kill:
			p.C1G2Kill = new(C1G2Kill)
			if err := p.C1G2Kill.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Recommission:
			p.C1G2Recommission = new(C1G2Recommission)
			if err := p.C1G2Recommission.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Lock:
			p.C1G2Lock = new(C1G2Lock)
			if err := p.C1G2Lock.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockErase:
			p.C1G2BlockErase = new(C1G2BlockErase)
			if err := p.C1G2BlockErase.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockWrite:
			p.C1G2BlockWrite = new(C1G2BlockWrite)
			if err := p.C1G2BlockWrite.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockPermalock:
			p.C1G2BlockPermalock = new(C1G2BlockPermalock)
			if err := p.C1G2BlockPermalock.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2GetBlockPermalockStatus:
			p.C1G2GetBlockPermalockStatus = new(C1G2GetBlockPermalockStatus)
			if err := p.C1G2GetBlockPermalockStatus.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamClientRequestOpSpec:
			p.ClientRequestOpSpec = new(ClientRequestOpSpec)
			*p.ClientRequestOpSpec = ClientRequestOpSpec(binary.BigEndian.Uint16(data[4:]))
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading AccessCommand, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 210, ClientRequestOpSpec.
func (p *ClientRequestOpSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamClientRequestOpSpec, 2, len(data), true); err != nil {
		return err
	}
	*p = ClientRequestOpSpec(binary.BigEndian.Uint16(data))
	return nil
}

// UnmarshalBinary Parameter 211, ClientRequestResponse.
func (p *ClientRequestResponse) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamClientRequestResponse, 10, len(data), false); err != nil {
		return err
	}
	p.AccessSpecID = binary.BigEndian.Uint32(data)
	data = data[4:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamEPCData {
		return fmt.Errorf("expected ParamEPCData, but found %v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamEPCData says it has %d bytes, but only %d "+
				"bytes remain", subLen, len(data))
		}
		if err := p.EPCData.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2Read:
			p.C1G2Read = new(C1G2Read)
			if err := p.C1G2Read.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Write:
			p.C1G2Write = new(C1G2Write)
			if err := p.C1G2Write.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Kill:
			p.C1G2Kill = new(C1G2Kill)
			if err := p.C1G2Kill.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Recommission:
			p.C1G2Recommission = new(C1G2Recommission)
			if err := p.C1G2Recommission.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2Lock:
			p.C1G2Lock = new(C1G2Lock)
			if err := p.C1G2Lock.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockErase:
			p.C1G2BlockErase = new(C1G2BlockErase)
			if err := p.C1G2BlockErase.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockWrite:
			p.C1G2BlockWrite = new(C1G2BlockWrite)
			if err := p.C1G2BlockWrite.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2BlockPermalock:
			p.C1G2BlockPermalock = new(C1G2BlockPermalock)
			if err := p.C1G2BlockPermalock.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2GetBlockPermalockStatus:
			p.C1G2GetBlockPermalockStatus = new(C1G2GetBlockPermalockStatus)
			if err := p.C1G2GetBlockPermalockStatus.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamClientRequestOpSpec:
			p.ClientRequestOpSpec = new(ClientRequestOpSpec)
			*p.ClientRequestOpSpec = ClientRequestOpSpec(binary.BigEndian.Uint16(data[4:]))
		case ParamCustom:
			p.Custom = new(Custom)
			if err := p.Custom.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading ClientRequestResponse, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 217, LLRPConfigurationStateValue.
func (p *LLRPConfigurationStateValue) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLLRPConfigurationStateValue, 4, len(data), true); err != nil {
		return err
	}
	*p = LLRPConfigurationStateValue(binary.BigEndian.Uint32(data))
	return nil
}

// UnmarshalBinary Parameter 218, Identification.
func (p *Identification) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamIdentification, 3, len(data), false); err != nil {
		return err
	}
	p.IDType = IDType(data[0])
	if arrLen := int(binary.BigEndian.Uint16(data[1:])); arrLen > len(data[3:]) {
		return fmt.Errorf("ReaderID ([]byte) declares it has %d bytes, but "+
			"only %d bytes are available", arrLen, len(data[3:]))
	} else if arrLen != 0 {
		p.ReaderID = make([]byte, arrLen)
		copy(p.ReaderID, data[3:])
		data = data[arrLen+3:]
	} else {
		data = data[3:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading Identification, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 219, GPOWriteData.
func (p *GPOWriteData) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGPOWriteData, 3, len(data), true); err != nil {
		return err
	}
	p.Port = binary.BigEndian.Uint16(data)
	p.Data = data[2]>>7 != 0
	return nil
}

// UnmarshalBinary Parameter 220, KeepAliveSpec.
func (p *KeepAliveSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamKeepAliveSpec, 5, len(data), true); err != nil {
		return err
	}
	p.Trigger = KeepAliveTriggerType(data[0])
	p.Interval = binary.BigEndian.Uint32(data[1:])
	return nil
}

// UnmarshalBinary Parameter 221, AntennaProperties.
func (p *AntennaProperties) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAntennaProperties, 5, len(data), true); err != nil {
		return err
	}
	p.AntennaConnected = data[0]>>7 != 0
	p.AntennaID = AntennaID(binary.BigEndian.Uint16(data[1:]))
	p.AntennaGain = MillibelIsotropic(binary.BigEndian.Uint16(data[3:]))
	return nil
}

// UnmarshalBinary Parameter 222, AntennaConfiguration.
func (p *AntennaConfiguration) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAntennaConfiguration, 2, len(data), false); err != nil {
		return err
	}
	p.AntennaID = AntennaID(binary.BigEndian.Uint16(data))
	data = data[2:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamRFReceiver:
			p.RFReceiver = new(RFReceiver)
			*p.RFReceiver = RFReceiver(binary.BigEndian.Uint16(data[4:]))
		case ParamRFTransmitter:
			p.RFTransmitter = new(RFTransmitter)
			if err := p.RFTransmitter.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2InventoryCommand:
			p.C1G2InventoryCommand = new(C1G2InventoryCommand)
			if err := p.C1G2InventoryCommand.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading AntennaConfiguration, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 223, RFReceiver.
func (p *RFReceiver) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFReceiver, 2, len(data), true); err != nil {
		return err
	}
	*p = RFReceiver(binary.BigEndian.Uint16(data))
	return nil
}

// UnmarshalBinary Parameter 224, RFTransmitter.
func (p *RFTransmitter) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFTransmitter, 6, len(data), true); err != nil {
		return err
	}
	p.HopTableID = binary.BigEndian.Uint16(data)
	p.ChannelIndex = binary.BigEndian.Uint16(data[2:])
	p.TransmitPowerIndex = binary.BigEndian.Uint16(data[4:])
	return nil
}

// UnmarshalBinary Parameter 225, GPIPortCurrentState.
func (p *GPIPortCurrentState) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGPIPortCurrentState, 4, len(data), true); err != nil {
		return err
	}
	p.Port = binary.BigEndian.Uint16(data)
	p.Enabled = data[2]>>7 != 0
	p.State = GPIStateType(data[3])
	return nil
}

// UnmarshalBinary Parameter 226, EventsAndReports.
func (p *EventsAndReports) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamEventsAndReports, 1, len(data), true); err != nil {
		return err
	}
	*p = EventsAndReports(data[0]>>7 != 0)
	return nil
}

// UnmarshalBinary Parameter 237, ROReportSpec.
func (p *ROReportSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROReportSpec, 9, len(data), false); err != nil {
		return err
	}
	p.Trigger = ROReportTriggerType(data[0])
	p.N = binary.BigEndian.Uint16(data[1:])
	data = data[3:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamTagReportContentSelector {
		return fmt.Errorf("expected ParamTagReportContentSelector, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamTagReportContentSelector says it has %d "+
				"bytes, but only %d bytes remain", subLen, len(data))
		}
		if err := p.TagReportContentSelector.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading ROReportSpec, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 238, TagReportContentSelector.
func (p *TagReportContentSelector) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamTagReportContentSelector, 2, len(data), false); err != nil {
		return err
	}
	p.EnableROSpecID = data[0]>>7 != 0
	p.EnableSpecIndex = data[0]>>6&1 != 0
	p.EnableInventoryParamSpecID = data[0]>>5&1 != 0
	p.EnableAntennaID = data[0]>>4&1 != 0
	p.EnableChannelIndex = data[0]>>3&1 != 0
	p.EnablePeakRSSI = data[0]>>2&1 != 0
	p.EnableFirstSeenTimestamp = data[0]>>1&1 != 0
	p.EnableLastSeenTimestamp = data[0]&1 != 0
	p.EnableTagSeenCount = data[1]>>7 != 0
	p.EnableAccessSpecID = data[1]>>6&1 != 0
	data = data[2:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2EPCMemorySelector {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamC1G2EPCMemorySelector says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		p.C1G2EPCMemorySelector = new(C1G2EPCMemorySelector)
		if err := p.C1G2EPCMemorySelector.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading TagReportContentSelector, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 239, AccessReportSpec.
func (p *AccessReportSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAccessReportSpec, 1, len(data), true); err != nil {
		return err
	}
	*p = AccessReportSpec(AccessReportTriggerType(data[0]))
	return nil
}

// UnmarshalBinary Parameter 240, TagReportData.
func (p *TagReportData) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamTagReportData, 6, len(data), false); err != nil {
		return err
	}
	// sub-parameters
	{
		var pt ParamType
		if data[0]&0x80 != 0 {
			// TV parameter
			pt = ParamType(data[0] & 0x7F)
		} else if len(data) < 4 {
			return fmt.Errorf("expecting a TLV header, but %d < 4 byte remain",
				len(data))
		} else {
			pt = ParamType(binary.BigEndian.Uint16(data))
		}
		switch pt {
		case ParamEPCData:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return fmt.Errorf("ParamEPCData says it has %d bytes, but only %d "+
					"bytes remain", subLen, len(data))
			}
			if err := p.EPCData.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamEPC96:
			if err := p.EPC96.UnmarshalBinary(data[1:13]); err != nil {
				return err
			}
			data = data[13:]
		default:
			return fmt.Errorf("unexpected parameter %v when unmarshaling "+
				"ParamTagReportData", pt)
		}
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 1 {
		var pt ParamType
		if data[0]&0x80 != 0 {
			// TV parameter
			pt = ParamType(data[0] & 0x7F)
		} else if len(data) < 4 {
			return fmt.Errorf("expecting a TLV header, but %d < 4 byte remain",
				len(data))
		} else {
			pt = ParamType(binary.BigEndian.Uint16(data))
		}
		switch pt {
		case ParamROSpecID:
			p.ROSpecID = new(ROSpecID)
			*p.ROSpecID = ROSpecID(binary.BigEndian.Uint32(data[1:]))
			data = data[5:]
		case ParamSpecIndex:
			p.SpecIndex = new(SpecIndex)
			*p.SpecIndex = SpecIndex(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamInventoryParameterSpecID:
			p.InventoryParameterSpecID = new(InventoryParameterSpecID)
			*p.InventoryParameterSpecID = InventoryParameterSpecID(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamAntennaID:
			p.AntennaID = new(AntennaID)
			*p.AntennaID = AntennaID(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamPeakRSSI:
			p.PeakRSSI = new(PeakRSSI)
			*p.PeakRSSI = PeakRSSI(DecibelMilliwatt8(data[1]))
			data = data[2:]
		case ParamChannelIndex:
			p.ChannelIndex = new(ChannelIndex)
			*p.ChannelIndex = ChannelIndex(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamFirstSeenUTC:
			p.FirstSeenUTC = new(FirstSeenUTC)
			*p.FirstSeenUTC = FirstSeenUTC(binary.BigEndian.Uint64(data[1:]))
			data = data[9:]
		case ParamFirstSeenUptime:
			p.FirstSeenUptime = new(FirstSeenUptime)
			*p.FirstSeenUptime = FirstSeenUptime(binary.BigEndian.Uint64(data[1:]))
			data = data[9:]
		case ParamLastSeenUTC:
			p.LastSeenUTC = new(LastSeenUTC)
			*p.LastSeenUTC = LastSeenUTC(binary.BigEndian.Uint64(data[1:]))
			data = data[9:]
		case ParamLastSeenUptime:
			p.LastSeenUptime = new(LastSeenUptime)
			*p.LastSeenUptime = LastSeenUptime(binary.BigEndian.Uint64(data[1:]))
			data = data[9:]
		case ParamTagSeenCount:
			p.TagSeenCount = new(TagSeenCount)
			*p.TagSeenCount = TagSeenCount(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamC1G2PC:
			p.C1G2PC = new(C1G2PC)
			if err := p.C1G2PC.UnmarshalBinary(data[1:3]); err != nil {
				return err
			}
			data = data[3:]
		case ParamC1G2XPCW1:
			p.C1G2XPCW1 = new(C1G2XPCW1)
			*p.C1G2XPCW1 = C1G2XPCW1(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamC1G2XPCW2:
			p.C1G2XPCW2 = new(C1G2XPCW2)
			*p.C1G2XPCW2 = C1G2XPCW2(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamC1G2CRC:
			p.C1G2CRC = new(C1G2CRC)
			*p.C1G2CRC = C1G2CRC(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamAccessSpecID:
			p.AccessSpecID = new(AccessSpecID)
			*p.AccessSpecID = AccessSpecID(binary.BigEndian.Uint32(data[1:]))
			data = data[5:]
		case ParamC1G2ReadOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return fmt.Errorf("ParamC1G2ReadOpSpecResult says it has %d "+
					"bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2ReadOpSpecResult = new(C1G2ReadOpSpecResult)
			if err := p.C1G2ReadOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2WriteOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return fmt.Errorf("ParamC1G2WriteOpSpecResult says it has %d "+
					"bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2WriteOpSpecResult = new(C1G2WriteOpSpecResult)
			if err := p.C1G2WriteOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2KillOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return fmt.Errorf("ParamC1G2KillOpSpecResult says it has %d "+
					"bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2KillOpSpecResult = new(C1G2KillOpSpecResult)
			if err := p.C1G2KillOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2LockOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return fmt.Errorf("ParamC1G2LockOpSpecResult says it has %d "+
					"bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2LockOpSpecResult = new(C1G2LockOpSpecResult)
			if err := p.C1G2LockOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2BlockEraseOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return fmt.Errorf("ParamC1G2BlockEraseOpSpecResult says it has %d "+
					"bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2BlockEraseOpSpecResult = new(C1G2BlockEraseOpSpecResult)
			if err := p.C1G2BlockEraseOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2BlockWriteOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return fmt.Errorf("ParamC1G2BlockWriteOpSpecResult says it has %d "+
					"bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2BlockWriteOpSpecResult = new(C1G2BlockWriteOpSpecResult)
			if err := p.C1G2BlockWriteOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2RecommissionOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return fmt.Errorf("ParamC1G2RecommissionOpSpecResult says it has "+
					"%d bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2RecommissionOpSpecResult = new(C1G2RecommissionOpSpecResult)
			if err := p.C1G2RecommissionOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2BlockPermalockOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return fmt.Errorf("ParamC1G2BlockPermalockOpSpecResult says it "+
					"has %d bytes, but only %d bytes remain", subLen, len(data))
			}
			p.C1G2BlockPermalockOpSpecResult = new(C1G2BlockPermalockOpSpecResult)
			if err := p.C1G2BlockPermalockOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamC1G2GetBlockPermalockStatusOpSpecResult:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return fmt.Errorf("ParamC1G2GetBlockPermalockStatusOpSpecResult "+
					"says it has %d bytes, but only %d bytes remain", subLen,
					len(data))
			}
			p.C1G2GetBlockPermalockStatusOpSpecResult = new(C1G2GetBlockPermalockStatusOpSpecResult)
			if err := p.C1G2GetBlockPermalockStatusOpSpecResult.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			data = data[subLen:]
		case ParamClientRequestOpSpecResult:
			p.ClientRequestOpSpecResult = new(ClientRequestOpSpecResult)
			*p.ClientRequestOpSpecResult = ClientRequestOpSpecResult(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		default:
			break paramGroup1
		}
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading TagReportData, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 241, EPCData.
func (p *EPCData) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamEPCData, 2, len(data), false); err != nil {
		return err
	}
	p.EPCNumBits = binary.BigEndian.Uint16(data)
	// Go right shift on signed ints is arithmetic, not logical
	if nBytes := 1 + ((int(p.EPCNumBits) - 1) >> 3); nBytes > len(data[2:]) {
		return fmt.Errorf("EPC (bit array) declares it has %d bits (%d "+
			"bytes), but only %d bytes are available", p.EPCNumBits, nBytes,
			len(data[2:]))
	} else if nBytes != 0 {
		p.EPC = make([]byte, nBytes)
		copy(p.EPC, data[2:])
		data = data[nBytes+2:]
	} else {
		data = data[2:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading EPCData, but an unexpected %d "+
			"bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 242, RFSurveyReportData.
func (p *RFSurveyReportData) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFSurveyReportData, 26, len(data), false); err != nil {
		return err
	}
	// sub-parameters

paramGroup0:
	for len(data) >= 1 {
		pt := ParamType(data[0] & 0x7F)
		switch pt {
		case ParamROSpecID:
			p.ROSpecID = new(ROSpecID)
			*p.ROSpecID = ROSpecID(binary.BigEndian.Uint32(data[1:]))
			data = data[5:]
		case ParamSpecIndex:
			p.SpecIndex = new(SpecIndex)
			*p.SpecIndex = SpecIndex(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		default:
			break paramGroup0
		}
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamFrequencyRSSILevelEntry:
			var tmp FrequencyRSSILevelEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.FrequencyRSSILevelEntries = append(p.FrequencyRSSILevelEntries, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading RFSurveyReportData, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 243, FrequencyRSSILevelEntry.
func (p *FrequencyRSSILevelEntry) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFrequencyRSSILevelEntry, 22, len(data), false); err != nil {
		return err
	}
	p.Frequency = binary.BigEndian.Uint32(data)
	p.Bandwidth = binary.BigEndian.Uint32(data[4:])
	p.AverageRSSI = DecibelMilliwatt8(data[8])
	p.PeakRSSI = DecibelMilliwatt8(data[9])
	data = data[10:]
	// sub-parameters
	{
		pt := ParamType(binary.BigEndian.Uint16(data))
		switch pt {
		case ParamUTCTimestamp:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return fmt.Errorf("ParamUTCTimestamp says it has %d bytes, but "+
					"only %d bytes remain", subLen, len(data))
			}
			p.UTCTimestamp = UTCTimestamp(binary.BigEndian.Uint64(data[4:]))
			data = data[subLen:]
		case ParamUptime:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return fmt.Errorf("ParamUptime says it has %d bytes, but only %d "+
					"bytes remain", subLen, len(data))
			}
			p.Uptime = Uptime(binary.BigEndian.Uint64(data[4:]))
			data = data[subLen:]
		default:
			return fmt.Errorf("unexpected parameter %v when unmarshaling "+
				"ParamFrequencyRSSILevelEntry", pt)
		}
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading FrequencyRSSILevelEntry, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 244, ReaderEventNotificationSpec.
func (p *ReaderEventNotificationSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReaderEventNotificationSpec, 7, len(data), false); err != nil {
		return err
	}
	// sub-parameters

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamEventNotificationState:
			var tmp EventNotificationState
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.EventNotificationStates = append(p.EventNotificationStates, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading ReaderEventNotificationSpec, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 245, EventNotificationState.
func (p *EventNotificationState) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamEventNotificationState, 3, len(data), true); err != nil {
		return err
	}
	p.ReaderEventType = ReaderEventType(binary.BigEndian.Uint16(data))
	p.NotificationEnabled = data[2]>>7 != 0
	return nil
}

// UnmarshalBinary Parameter 246, ReaderEventNotificationData.
func (p *ReaderEventNotificationData) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReaderEventNotificationData, 12, len(data), false); err != nil {
		return err
	}
	// sub-parameters
	{
		pt := ParamType(binary.BigEndian.Uint16(data))
		switch pt {
		case ParamUTCTimestamp:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return fmt.Errorf("ParamUTCTimestamp says it has %d bytes, but "+
					"only %d bytes remain", subLen, len(data))
			}
			p.UTCTimestamp = UTCTimestamp(binary.BigEndian.Uint64(data[4:]))
			data = data[subLen:]
		case ParamUptime:
			subLen := binary.BigEndian.Uint16(data[2:])
			if int(subLen) > len(data) {
				return fmt.Errorf("ParamUptime says it has %d bytes, but only %d "+
					"bytes remain", subLen, len(data))
			}
			p.Uptime = Uptime(binary.BigEndian.Uint64(data[4:]))
			data = data[subLen:]
		default:
			return fmt.Errorf("unexpected parameter %v when unmarshaling "+
				"ParamReaderEventNotificationData", pt)
		}
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamHoppingEvent:
			p.HoppingEvent = new(HoppingEvent)
			*p.HoppingEvent = HoppingEvent(binary.BigEndian.Uint16(data[4:]))
		case ParamGPIEvent:
			p.GPIEvent = new(GPIEvent)
			if err := p.GPIEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamROSpecEvent:
			p.ROSpecEvent = new(ROSpecEvent)
			if err := p.ROSpecEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamReportBufferLevelWarningEvent:
			p.ReportBufferLevelWarningEvent = new(ReportBufferLevelWarningEvent)
			*p.ReportBufferLevelWarningEvent = ReportBufferLevelWarningEvent(data[4])
		case ParamReportBufferOverflowErrorEvent:
			p.ReportBufferOverflowErrorEvent = new(ReportBufferOverflowErrorEvent)
			if err := p.ReportBufferOverflowErrorEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamReaderExceptionEvent:
			p.ReaderExceptionEvent = new(ReaderExceptionEvent)
			if err := p.ReaderExceptionEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamRFSurveyEvent:
			p.RFSurveyEvent = new(RFSurveyEvent)
			if err := p.RFSurveyEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamAISpecEvent:
			p.AISpecEvent = new(AISpecEvent)
			if err := p.AISpecEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamAntennaEvent:
			p.AntennaEvent = new(AntennaEvent)
			if err := p.AntennaEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamConnectionAttemptEvent:
			p.ConnectionAttemptEvent = new(ConnectionAttemptEvent)
			*p.ConnectionAttemptEvent = ConnectionAttemptEvent(ConnectionAttemptEventType(binary.BigEndian.Uint16(data[4:])))
		case ParamConnectionCloseEvent:
			p.ConnectionCloseEvent = new(ConnectionCloseEvent)
			if err := p.ConnectionCloseEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamSpecLoopEvent:
			p.SpecLoopEvent = new(SpecLoopEvent)
			if err := p.SpecLoopEvent.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading ReaderEventNotificationData, but "+
			"an unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 247, HoppingEvent.
func (p *HoppingEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamHoppingEvent, 2, len(data), true); err != nil {
		return err
	}
	*p = HoppingEvent(binary.BigEndian.Uint16(data))
	return nil
}

// UnmarshalBinary Parameter 248, GPIEvent.
func (p *GPIEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamGPIEvent, 3, len(data), true); err != nil {
		return err
	}
	p.Port = binary.BigEndian.Uint16(data)
	p.Event = data[2]>>7 != 0
	return nil
}

// UnmarshalBinary Parameter 249, ROSpecEvent.
func (p *ROSpecEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamROSpecEvent, 9, len(data), true); err != nil {
		return err
	}
	p.Event = ROSpecEventType(data[0])
	p.ROSpecID = binary.BigEndian.Uint32(data[1:])
	p.PreemptingROSpecID = binary.BigEndian.Uint32(data[5:])
	return nil
}

// UnmarshalBinary Parameter 250, ReportBufferLevelWarningEvent.
func (p *ReportBufferLevelWarningEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReportBufferLevelWarningEvent, 1, len(data), true); err != nil {
		return err
	}
	*p = ReportBufferLevelWarningEvent(data[0])
	return nil
}

// UnmarshalBinary Parameter 251, ReportBufferOverflowErrorEvent.
func (p *ReportBufferOverflowErrorEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReportBufferOverflowErrorEvent, 0, len(data), true); err != nil {
		return err
	}
	return nil
}

// UnmarshalBinary Parameter 252, ReaderExceptionEvent.
func (p *ReaderExceptionEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamReaderExceptionEvent, 2, len(data), false); err != nil {
		return err
	}
	if strLen := int(binary.BigEndian.Uint16(data)); strLen > len(data[2:]) {
		return fmt.Errorf("Message (string) declares it has %d bytes, but "+
			"only %d bytes are available", strLen, len(data[2:]))
	} else if strLen != 0 {
		p.Message = string(data[2 : strLen+2])
		data = data[strLen+2:]
	} else {
		data = data[2:]
	}
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) >= 1 {
		pt := ParamType(data[0] & 0x7F)
		switch pt {
		case ParamROSpecID:
			p.ROSpecID = new(ROSpecID)
			*p.ROSpecID = ROSpecID(binary.BigEndian.Uint32(data[1:]))
			data = data[5:]
		case ParamSpecIndex:
			p.SpecIndex = new(SpecIndex)
			*p.SpecIndex = SpecIndex(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamInventoryParameterSpecID:
			p.InventoryParameterSpecID = new(InventoryParameterSpecID)
			*p.InventoryParameterSpecID = InventoryParameterSpecID(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamAntennaID:
			p.AntennaID = new(AntennaID)
			*p.AntennaID = AntennaID(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		case ParamAccessSpecID:
			p.AccessSpecID = new(AccessSpecID)
			*p.AccessSpecID = AccessSpecID(binary.BigEndian.Uint32(data[1:]))
			data = data[5:]
		case ParamOpSpecID:
			p.OpSpecID = new(OpSpecID)
			*p.OpSpecID = OpSpecID(binary.BigEndian.Uint16(data[1:]))
			data = data[3:]
		default:
			break paramGroup0
		}
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading ReaderExceptionEvent, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 253, RFSurveyEvent.
func (p *RFSurveyEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFSurveyEvent, 5, len(data), true); err != nil {
		return err
	}
	p.Event = RFSurveyEventType(data[0])
	p.ROSpecID = binary.BigEndian.Uint32(data[1:])
	return nil
}

// UnmarshalBinary Parameter 254, AISpecEvent.
func (p *AISpecEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAISpecEvent, 7, len(data), false); err != nil {
		return err
	}
	p.Event = AISpecEventType(data[0])
	p.ROSpecID = binary.BigEndian.Uint32(data[1:])
	p.SpecIndex = binary.BigEndian.Uint16(data[5:])
	data = data[7:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(data[0] & 0x7F); subType == ParamC1G2SingulationDetails {
		p.SingulationDetails = new(C1G2SingulationDetails)
		if err := p.SingulationDetails.UnmarshalBinary(data[1:5]); err != nil {
			return err
		}
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading AISpecEvent, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 255, AntennaEvent.
func (p *AntennaEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamAntennaEvent, 3, len(data), true); err != nil {
		return err
	}
	p.Event = AntennaEventType(data[0])
	p.AntennaID = AntennaID(binary.BigEndian.Uint16(data[1:]))
	return nil
}

// UnmarshalBinary Parameter 256, ConnectionAttemptEvent.
func (p *ConnectionAttemptEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamConnectionAttemptEvent, 2, len(data), true); err != nil {
		return err
	}
	*p = ConnectionAttemptEvent(ConnectionAttemptEventType(binary.BigEndian.Uint16(data)))
	return nil
}

// UnmarshalBinary Parameter 257, ConnectionCloseEvent.
func (p *ConnectionCloseEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamConnectionCloseEvent, 0, len(data), true); err != nil {
		return err
	}
	return nil
}

// UnmarshalBinary Parameter 287, LLRPStatus.
func (p *LLRPStatus) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLLRPStatus, 4, len(data), false); err != nil {
		return err
	}
	p.Status = StatusCode(binary.BigEndian.Uint16(data))
	if strLen := int(binary.BigEndian.Uint16(data[2:])); strLen > len(data[4:]) {
		return fmt.Errorf("ErrorDescription (string) declares it has %d "+
			"bytes, but only %d bytes are available", strLen, len(data[4:]))
	} else if strLen != 0 {
		p.ErrorDescription = string(data[4 : strLen+4])
		data = data[strLen+4:]
	} else {
		data = data[4:]
	}
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamFieldError:
			p.FieldError = new(FieldError)
			if err := p.FieldError.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamParameterError:
			p.ParameterError = new(ParameterError)
			if err := p.ParameterError.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading LLRPStatus, but an unexpected %d "+
			"bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 288, FieldError.
func (p *FieldError) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamFieldError, 4, len(data), true); err != nil {
		return err
	}
	p.FieldIndex = binary.BigEndian.Uint16(data)
	p.ErrorCode = StatusCode(binary.BigEndian.Uint16(data[2:]))
	return nil
}

// UnmarshalBinary Parameter 289, ParameterError.
func (p *ParameterError) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamParameterError, 4, len(data), false); err != nil {
		return err
	}
	p.ParameterType = ParamType(binary.BigEndian.Uint16(data))
	p.ErrorCode = StatusCode(binary.BigEndian.Uint16(data[2:]))
	data = data[4:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamParameterError:
			p.ParameterError = new(ParameterError)
			if err := p.ParameterError.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamFieldError:
			p.FieldError = new(FieldError)
			if err := p.FieldError.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading ParameterError, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 327, C1G2LLRPCapabilities.
func (p *C1G2LLRPCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2LLRPCapabilities, 3, len(data), true); err != nil {
		return err
	}
	p.SupportsBlockErase = data[0]>>7 != 0
	p.SupportsBlockWrite = data[0]>>6&1 != 0
	p.SupportsBlockPermalock = data[0]>>5&1 != 0
	p.SupportsTagRecommissioning = data[0]>>4&1 != 0
	p.SupportsUMIMethod2 = data[0]>>3&1 != 0
	p.SupportsXPC = data[0]>>2&1 != 0
	p.MaxSelectFiltersPerQuery = binary.BigEndian.Uint16(data[1:])
	return nil
}

// UnmarshalBinary Parameter 328, UHFC1G2RFModeTable.
func (p *UHFC1G2RFModeTable) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamUHFC1G2RFModeTable, 32, len(data), false); err != nil {
		return err
	}
	// sub-parameters

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamUHFC1G2RFModeTableEntry:
			var tmp UHFC1G2RFModeTableEntry
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.UHFC1G2RFModeTableEntries = append(p.UHFC1G2RFModeTableEntries, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading UHFC1G2RFModeTable, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 329, UHFC1G2RFModeTableEntry.
func (p *UHFC1G2RFModeTableEntry) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamUHFC1G2RFModeTableEntry, 28, len(data), true); err != nil {
		return err
	}
	p.ModeID = binary.BigEndian.Uint32(data)
	p.DivideRatio = DivideRatio(data[4] >> 7)
	p.IsEPCHagConformant = data[4]>>6&1 != 0
	p.Modulation = BackscatterMod(data[5])
	p.ForwardLinkModulation = FwdLinkMod(data[6])
	p.SpectralMask = SpectralMaskType(data[7])
	p.BackscatterDataRate = binary.BigEndian.Uint32(data[8:])
	p.PIERatio = binary.BigEndian.Uint32(data[12:])
	p.MinTariTime = binary.BigEndian.Uint32(data[16:])
	p.MaxTariTime = binary.BigEndian.Uint32(data[20:])
	p.StepTariTime = binary.BigEndian.Uint32(data[24:])
	return nil
}

// UnmarshalBinary Parameter 330, C1G2InventoryCommand.
func (p *C1G2InventoryCommand) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2InventoryCommand, 1, len(data), false); err != nil {
		return err
	}
	p.TagInventoryStateAware = data[0]>>7 != 0
	data = data[1:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2Filter:
			var tmp C1G2Filter
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Filters = append(p.Filters, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2RFControl:
			p.RFControl = new(C1G2RFControl)
			if err := p.RFControl.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2SingulationControl:
			p.SingulationControl = new(C1G2SingulationControl)
			if err := p.SingulationControl.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup2:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamCustom:
			var tmp Custom
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.Custom = append(p.Custom, tmp)
		default:
			break paramGroup2
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading C1G2InventoryCommand, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 331, C1G2Filter.
func (p *C1G2Filter) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Filter, 10, len(data), false); err != nil {
		return err
	}
	p.TruncateAction = C1G2FilterTruncateActionType(data[0] >> 6)
	data = data[1:]
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamC1G2TagInventoryMask {
		return fmt.Errorf("expected ParamC1G2TagInventoryMask, but found "+
			"%v", subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamC1G2TagInventoryMask says it has %d bytes, "+
				"but only %d bytes remain", subLen, len(data))
		}
		if err := p.TagInventoryMask.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}

paramGroup1:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2TagInventoryStateAwareFilterAction:
			p.AwareFilterAction = new(C1G2TagInventoryStateAwareFilterAction)
			if err := p.AwareFilterAction.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
		case ParamC1G2TagInventoryStateUnawareFilterAction:
			p.UnawareFilterAction = new(C1G2TagInventoryStateUnawareFilterAction)
			*p.UnawareFilterAction = C1G2TagInventoryStateUnawareFilterAction(C1G2TagInventoryStateUnawareFilterActionType(data[4]))
		default:
			break paramGroup1
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading C1G2Filter, but an unexpected %d "+
			"bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 332, C1G2TagInventoryMask.
func (p *C1G2TagInventoryMask) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TagInventoryMask, 5, len(data), false); err != nil {
		return err
	}
	p.MemoryBank = data[0] >> 6
	p.MostSignificantBit = binary.BigEndian.Uint16(data[1:])
	p.TagMaskNumBits = binary.BigEndian.Uint16(data[3:])
	// Go right shift on signed ints is arithmetic, not logical
	if nBytes := 1 + ((int(p.TagMaskNumBits) - 1) >> 3); nBytes > len(data[5:]) {
		return fmt.Errorf("TagMask (bit array) declares it has %d bits (%d "+
			"bytes), but only %d bytes are available", p.TagMaskNumBits, nBytes,
			len(data[5:]))
	} else if nBytes != 0 {
		p.TagMask = make([]byte, nBytes)
		copy(p.TagMask, data[5:])
		data = data[nBytes+5:]
	} else {
		data = data[5:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading C1G2TagInventoryMask, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 333, C1G2TagInventoryStateAwareFilterAction.
func (p *C1G2TagInventoryStateAwareFilterAction) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TagInventoryStateAwareFilterAction, 2, len(data), true); err != nil {
		return err
	}
	p.Target = C1G2TagInventoryTargetType(data[0])
	p.FilterAction = C1G2TagInventoryStateAwareFilterActionType(data[1])
	return nil
}

// UnmarshalBinary Parameter 334, C1G2TagInventoryStateUnawareFilterAction.
func (p *C1G2TagInventoryStateUnawareFilterAction) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TagInventoryStateUnawareFilterAction, 1, len(data), true); err != nil {
		return err
	}
	*p = C1G2TagInventoryStateUnawareFilterAction(C1G2TagInventoryStateUnawareFilterActionType(data[0]))
	return nil
}

// UnmarshalBinary Parameter 335, C1G2RFControl.
func (p *C1G2RFControl) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2RFControl, 4, len(data), true); err != nil {
		return err
	}
	p.RFModeID = binary.BigEndian.Uint16(data)
	p.Tari = binary.BigEndian.Uint16(data[2:])
	return nil
}

// UnmarshalBinary Parameter 336, C1G2SingulationControl.
func (p *C1G2SingulationControl) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2SingulationControl, 7, len(data), false); err != nil {
		return err
	}
	p.Session = data[0] >> 6
	p.TagPopulation = binary.BigEndian.Uint16(data[1:])
	p.TagTransitTime = binary.BigEndian.Uint32(data[3:])
	data = data[7:]
	// sub-parameters
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2TagInventoryStateAwareSingulationAction {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamC1G2TagInventoryStateAwareSingulationAction "+
				"says it has %d bytes, but only %d bytes remain", subLen, len(data))
		}
		p.InvAwareAction = new(C1G2TagInventoryStateAwareSingulationAction)
		if err := p.InvAwareAction.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading C1G2SingulationControl, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 337, C1G2TagInventoryStateAwareSingulationAction.
func (p *C1G2TagInventoryStateAwareSingulationAction) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TagInventoryStateAwareSingulationAction, 1, len(data), true); err != nil {
		return err
	}
	p.SessionState = SessionState(data[0] >> 7)
	p.SLState = SLState(data[0] >> 6 & 1)
	return nil
}

// UnmarshalBinary Parameter 338, C1G2TagSpec.
func (p *C1G2TagSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TagSpec, 11, len(data), false); err != nil {
		return err
	}
	// sub-parameters
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType != ParamC1G2TargetTag {
		return fmt.Errorf("expected ParamC1G2TargetTag, but found %v",
			subType)
	} else {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamC1G2TargetTag says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		if err := p.TagPattern1.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) == 0 {
		return nil
	}
	if subType := ParamType(binary.BigEndian.Uint16(data)); subType == ParamC1G2TargetTag {
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("ParamC1G2TargetTag says it has %d bytes, but "+
				"only %d bytes remain", subLen, len(data))
		}
		p.TagPattern2 = new(C1G2TargetTag)
		if err := p.TagPattern2.UnmarshalBinary(data[4:subLen]); err != nil {
			return err
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading C1G2TagSpec, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 339, C1G2TargetTag.
func (p *C1G2TargetTag) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2TargetTag, 7, len(data), false); err != nil {
		return err
	}
	p.C1G2MemoryBank = data[0] >> 6
	p.MatchFlag = data[0]>>5&1 != 0
	p.MostSignificantBit = binary.BigEndian.Uint16(data[1:])
	p.TagMaskNumBits = binary.BigEndian.Uint16(data[3:])
	// Go right shift on signed ints is arithmetic, not logical
	if nBytes := 1 + ((int(p.TagMaskNumBits) - 1) >> 3); nBytes > len(data[5:]) {
		return fmt.Errorf("TagMask (bit array) declares it has %d bits (%d "+
			"bytes), but only %d bytes are available", p.TagMaskNumBits, nBytes,
			len(data[5:]))
	} else if nBytes != 0 {
		p.TagMask = make([]byte, nBytes)
		copy(p.TagMask, data[5:])
		data = data[nBytes+5:]
	} else {
		data = data[5:]
	}
	p.TagDataNumBits = binary.BigEndian.Uint16(data)
	// Go right shift on signed ints is arithmetic, not logical
	if nBytes := 1 + ((int(p.TagDataNumBits) - 1) >> 3); nBytes > len(data[2:]) {
		return fmt.Errorf("TagData (bit array) declares it has %d bits (%d "+
			"bytes), but only %d bytes are available", p.TagDataNumBits, nBytes,
			len(data[2:]))
	} else if nBytes != 0 {
		p.TagData = make([]byte, nBytes)
		copy(p.TagData, data[2:])
		data = data[nBytes+2:]
	} else {
		data = data[2:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading C1G2TargetTag, but an unexpected "+
			"%d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 341, C1G2Read.
func (p *C1G2Read) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Read, 11, len(data), true); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	p.WordCount = binary.BigEndian.Uint16(data[9:])
	return nil
}

// UnmarshalBinary Parameter 342, C1G2Write.
func (p *C1G2Write) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Write, 11, len(data), false); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[9:])); int64(arrLen)*2 > int64(len(data[11:])) {
		return fmt.Errorf("Data ([]uint16) declares it has %d*2 bytes, but "+
			"only %d bytes are available", arrLen, len(data[11:]))
	} else if arrLen != 0 {
		p.Data = make([]uint16, arrLen)
		for i, pos := 0, 11; i < arrLen; i, pos = i+1, pos+2 {
			p.Data[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+11:]
	} else {
		data = data[11:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading C1G2Write, but an unexpected %d "+
			"bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 343, C1G2Kill.
func (p *C1G2Kill) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Kill, 6, len(data), true); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.KillPassword = binary.BigEndian.Uint32(data[2:])
	return nil
}

// UnmarshalBinary Parameter 344, C1G2Lock.
func (p *C1G2Lock) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Lock, 12, len(data), false); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	data = data[6:]
	// sub-parameters

paramGroup0:
	for len(data) >= 4 {
		pt := ParamType(binary.BigEndian.Uint16(data))
		subLen := binary.BigEndian.Uint16(data[2:])
		if int(subLen) > len(data) {
			return fmt.Errorf("%v says it has %d bytes, but only %d bytes "+
				"remain", pt, subLen, len(data))
		}
		switch pt {
		case ParamC1G2LockPayload:
			var tmp C1G2LockPayload
			if err := tmp.UnmarshalBinary(data[4:subLen]); err != nil {
				return err
			}
			p.C1G2LockPayloads = append(p.C1G2LockPayloads, tmp)
		default:
			break paramGroup0
		}
		data = data[subLen:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading C1G2Lock, but an unexpected %d "+
			"bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 345, C1G2LockPayload.
func (p *C1G2LockPayload) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2LockPayload, 2, len(data), true); err != nil {
		return err
	}
	p.LockPrivilege = LockPrivilegeType(data[0])
	p.LockData = LockDataType(data[1])
	return nil
}

// UnmarshalBinary Parameter 346, C1G2BlockErase.
func (p *C1G2BlockErase) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockErase, 11, len(data), true); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	p.WordCount = binary.BigEndian.Uint16(data[9:])
	return nil
}

// UnmarshalBinary Parameter 347, C1G2BlockWrite.
func (p *C1G2BlockWrite) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockWrite, 11, len(data), false); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.WordAddress = binary.BigEndian.Uint16(data[7:])
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[9:])); int64(arrLen)*2 > int64(len(data[11:])) {
		return fmt.Errorf("Data ([]uint16) declares it has %d*2 bytes, but "+
			"only %d bytes are available", arrLen, len(data[11:]))
	} else if arrLen != 0 {
		p.Data = make([]uint16, arrLen)
		for i, pos := 0, 11; i < arrLen; i, pos = i+1, pos+2 {
			p.Data[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+11:]
	} else {
		data = data[11:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading C1G2BlockWrite, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 348, C1G2EPCMemorySelector.
func (p *C1G2EPCMemorySelector) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2EPCMemorySelector, 1, len(data), true); err != nil {
		return err
	}
	p.CRCEnabled = data[0]>>7 != 0
	p.PCBitsEnabled = data[0]>>6&1 != 0
	p.XPCBitsEnabled = data[0]>>5&1 != 0
	return nil
}

// UnmarshalBinary Parameter 349, C1G2ReadOpSpecResult.
func (p *C1G2ReadOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2ReadOpSpecResult, 5, len(data), false); err != nil {
		return err
	}
	p.C1G2ReadOpSpecResultType = C1G2ReadOpSpecResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[3:])); int64(arrLen)*2 > int64(len(data[5:])) {
		return fmt.Errorf("Data ([]uint16) declares it has %d*2 bytes, but "+
			"only %d bytes are available", arrLen, len(data[5:]))
	} else if arrLen != 0 {
		p.Data = make([]uint16, arrLen)
		for i, pos := 0, 5; i < arrLen; i, pos = i+1, pos+2 {
			p.Data[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+5:]
	} else {
		data = data[5:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading C1G2ReadOpSpecResult, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 350, C1G2WriteOpSpecResult.
func (p *C1G2WriteOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2WriteOpSpecResult, 5, len(data), true); err != nil {
		return err
	}
	p.C1G2WriteOpSpecResultType = C1G2WriteOpSpecResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	p.WordsWritten = binary.BigEndian.Uint16(data[3:])
	return nil
}

// UnmarshalBinary Parameter 351, C1G2KillOpSpecResult.
func (p *C1G2KillOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2KillOpSpecResult, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2KillResult = C1G2KillResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// UnmarshalBinary Parameter 352, C1G2LockOpSpecResult.
func (p *C1G2LockOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2LockOpSpecResult, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2LockResult = C1G2LockResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// UnmarshalBinary Parameter 353, C1G2BlockEraseOpSpecResult.
func (p *C1G2BlockEraseOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockEraseOpSpecResult, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2BlockEraseResult = C1G2BlockEraseResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// UnmarshalBinary Parameter 354, C1G2BlockWriteOpSpecResult.
func (p *C1G2BlockWriteOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockWriteOpSpecResult, 5, len(data), true); err != nil {
		return err
	}
	p.C1G2BlockWriteResult = C1G2BlockWriteResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	p.WordsWritten = binary.BigEndian.Uint16(data[3:])
	return nil
}

// UnmarshalBinary Parameter 355, LoopSpec.
func (p *LoopSpec) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamLoopSpec, 4, len(data), true); err != nil {
		return err
	}
	*p = LoopSpec(binary.BigEndian.Uint32(data))
	return nil
}

// UnmarshalBinary Parameter 356, SpecLoopEvent.
func (p *SpecLoopEvent) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamSpecLoopEvent, 8, len(data), true); err != nil {
		return err
	}
	p.ROSpecID = binary.BigEndian.Uint32(data)
	p.LoopCount = binary.BigEndian.Uint32(data[4:])
	return nil
}

// UnmarshalBinary Parameter 357, C1G2Recommission.
func (p *C1G2Recommission) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2Recommission, 7, len(data), true); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.KillPassword = binary.BigEndian.Uint32(data[2:])
	p.SB3 = data[6]>>2&1 != 0
	p.SB2 = data[6]>>1&1 != 0
	p.LSB = data[6]&1 != 0
	return nil
}

// UnmarshalBinary Parameter 358, C1G2BlockPermalock.
func (p *C1G2BlockPermalock) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockPermalock, 11, len(data), false); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.BlockAddress = binary.BigEndian.Uint16(data[7:])
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[9:])); int64(arrLen)*2 > int64(len(data[11:])) {
		return fmt.Errorf("BlockMask ([]uint16) declares it has %d*2 bytes, "+
			"but only %d bytes are available", arrLen, len(data[11:]))
	} else if arrLen != 0 {
		p.BlockMask = make([]uint16, arrLen)
		for i, pos := 0, 11; i < arrLen; i, pos = i+1, pos+2 {
			p.BlockMask[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+11:]
	} else {
		data = data[11:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading C1G2BlockPermalock, but an "+
			"unexpected %d bytes remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 359, C1G2GetBlockPermalockStatus.
func (p *C1G2GetBlockPermalockStatus) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2GetBlockPermalockStatus, 11, len(data), true); err != nil {
		return err
	}
	p.OpSpecID = binary.BigEndian.Uint16(data)
	p.AccessPassword = binary.BigEndian.Uint32(data[2:])
	p.C1G2MemoryBank = data[6] >> 6
	p.BlockAddress = binary.BigEndian.Uint16(data[7:])
	p.BlockRange = binary.BigEndian.Uint16(data[9:])
	return nil
}

// UnmarshalBinary Parameter 360, C1G2RecommissionOpSpecResult.
func (p *C1G2RecommissionOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2RecommissionOpSpecResult, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2RecommissionResult = C1G2RecommissionResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// UnmarshalBinary Parameter 361, C1G2BlockPermalockOpSpecResult.
func (p *C1G2BlockPermalockOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2BlockPermalockOpSpecResult, 3, len(data), true); err != nil {
		return err
	}
	p.C1G2BlockPermalockResult = C1G2BlockPermalockResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	return nil
}

// UnmarshalBinary Parameter 362, C1G2GetBlockPermalockStatusOpSpecResult.
func (p *C1G2GetBlockPermalockStatusOpSpecResult) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamC1G2GetBlockPermalockStatusOpSpecResult, 5, len(data), false); err != nil {
		return err
	}
	p.C1G2GetBlockPermalockStatusResult = C1G2GetBlockPermalockStatusResultType(data[0])
	p.OpSpecID = binary.BigEndian.Uint16(data[1:])
	// cast the len check to int64 to prevent overflow issues
	if arrLen := int(binary.BigEndian.Uint16(data[3:])); int64(arrLen)*2 > int64(len(data[5:])) {
		return fmt.Errorf("PermalockStatuses ([]uint16) declares it has %d*2 "+
			"bytes, but only %d bytes are available", arrLen, len(data[5:]))
	} else if arrLen != 0 {
		p.PermalockStatuses = make([]uint16, arrLen)
		for i, pos := 0, 5; i < arrLen; i, pos = i+1, pos+2 {
			p.PermalockStatuses[i] = binary.BigEndian.Uint16(data[pos:])
		}
		data = data[arrLen*2+5:]
	} else {
		data = data[5:]
	}
	if len(data) > 0 {
		return fmt.Errorf("finished reading "+
			"C1G2GetBlockPermalockStatusOpSpecResult, but an unexpected %d bytes "+
			"remain", len(data))
	}
	return nil
}

// UnmarshalBinary Parameter 363, MaximumReceiveSensitivity.
func (p *MaximumReceiveSensitivity) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamMaximumReceiveSensitivity, 2, len(data), true); err != nil {
		return err
	}
	*p = MaximumReceiveSensitivity(DecibelMilliwatt16(binary.BigEndian.Uint16(data)))
	return nil
}

// UnmarshalBinary Parameter 365, RFSurveyFrequencyCapabilities.
func (p *RFSurveyFrequencyCapabilities) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamRFSurveyFrequencyCapabilities, 8, len(data), true); err != nil {
		return err
	}
	p.MinFrequency = binary.BigEndian.Uint32(data)
	p.MaxFrequency = binary.BigEndian.Uint32(data[4:])
	return nil
}

// UnmarshalBinary Parameter 1023, Custom.
func (p *Custom) UnmarshalBinary(data []byte) error {
	if err := hasEnoughBytes(ParamCustom, 8, len(data), false); err != nil {
		return err
	}
	p.VendorID = binary.BigEndian.Uint32(data)
	p.Subtype = binary.BigEndian.Uint32(data[4:])
	if len(data)-8 == 0 {
		return nil
	}
	p.Data = make([]byte, len(data)-8)
	copy(p.Data, data[8:])
	data = data[8:]
	return nil
}
